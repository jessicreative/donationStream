import { ethers } from "ethers";
/**
 * Operation Helper Class
 * @description A helper class to create `Operation` objects which can be executed or batched.
 */
export default class Operation {
    constructor(txn, type, forwarderPopulatedPromise) {
        /**
         * Executes the operation via the provided signer.
         * @description Populates all fields of the transaction, signs it and sends it to the network.
         * @param signer The signer of the transaction
         * @param gasLimitMultiplier A multiplier to provide gasLimit buffer on top of the estimated gas limit (1.2x is the default)
         * @returns {ethers.providers.TransactionResponse} A TransactionResponse object which can be awaited
         */
        this.exec = async (signer, gasLimitMultiplier = 1.2) => {
            const populatedTransaction = await this.getPopulatedTransactionRequest(signer, gasLimitMultiplier);
            return await signer.sendTransaction(populatedTransaction);
        };
        /**
         * Get the populated transaction by awaiting `populateTransactionPromise`.
         * @description Note that we need to populate the txn with the signer.
         * NOTE: we use the forwarder populated promise if this exists
         * @returns {Promise<TransactionRequest>}
         */
        this.getPopulatedTransactionRequest = async (signer, gasLimitMultiplier = 1.2) => {
            var _a;
            const txnToPopulate = this.forwarderPopulatedPromise
                ? await this.forwarderPopulatedPromise
                : await this.populateTransactionPromise;
            const signerPopulatedTransaction = await signer.populateTransaction(txnToPopulate);
            // if gasLimit exists, an Overrides object has been passed or the user has explicitly set
            // a gasLimit for their transaction prior to execution and so we keep it as is else we apply
            // a specified or the default (1.2) multiplier on the gas limit.
            return txnToPopulate.gasLimit
                ? txnToPopulate
                : {
                    ...signerPopulatedTransaction,
                    gasLimit: 
                    // @note if gasLimit is null, this function will throw due to
                    // conversion to BigNumber, so we must round this number
                    // we can be more conservative by using Math.ceil instead of Math.round
                    Math.ceil(Number((_a = signerPopulatedTransaction.gasLimit) === null || _a === void 0 ? void 0 : _a.toString()) * gasLimitMultiplier),
                };
        };
        /**
         * Signs the populated transaction via the provided signer (what you intend on sending to the network).
         * @param signer The signer of the transaction
         * @returns {Promise<string>} Fully serialized, signed transaction
         */
        this.getSignedTransaction = async (signer) => {
            const populatedTransaction = await this.getPopulatedTransactionRequest(signer);
            const signedTxn = await signer.signTransaction(populatedTransaction);
            return signedTxn;
        };
        /**
         * Gets the transaction hash of the transaction.
         * @description Calculates this by getting the keccak256 hash of the signedTxn.
         * @param signer The signer of the transaction
         * @returns {Promise<string>} The transaction hash of the transaction
         */
        this.getTransactionHash = async (signer) => {
            const signedTxn = await this.getSignedTransaction(signer);
            return ethers.utils.keccak256(signedTxn);
        };
        this.populateTransactionPromise = txn;
        this.type = type;
        this.forwarderPopulatedPromise = forwarderPopulatedPromise;
    }
}
//# sourceMappingURL=Operation.js.map