"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typechain_1 = require("@superfluid-finance/ethereum-contracts/build/typechain");
const ethers_1 = require("ethers");
const Host_1 = __importDefault(require("./Host"));
const SFError_1 = require("./SFError");
const utils_1 = require("./utils");
const batchOperationTypeStringToTypeMap = new Map([
    ["ERC20_APPROVE", 1],
    ["ERC20_TRANSFER_FROM", 2],
    ["ERC777_SEND", 3],
    ["ERC20_INCREASE_ALLOWANCE", 4],
    ["ERC20_DECREASE_ALLOWANCE", 5],
    ["SUPERTOKEN_UPGRADE", 101],
    ["SUPERTOKEN_DOWNGRADE", 102],
    ["SUPERFLUID_CALL_AGREEMENT", 201],
    ["CALL_APP_ACTION", 202],
]);
/**
 * BatchCall Helper Class
 * @description A helper class to create `BatchCall` objects which can be executed.
 */
class BatchCall {
    constructor(options) {
        /**
         * Gets function arguments given an ABI and callData.
         * @param abi the abi fragments of a contract/function
         * @param callData call data of the function
         * @returns {ethers.utils.Result} call agreement function arguments
         */
        this.getCallDataFunctionArgs = (abi, callData) => (0, utils_1.getTransactionDescription)(abi, callData).args;
        /**
         * Given an `Operation` object, gets the `OperationStruct` object.
         * @param operation an `Operation` object
         * @param index the index of the `Operation` in the batchCall
         * @returns {Promise<OperationStruct>} OperationStruct object for batchCall
         */
        this.getOperationStruct = async (operation, index) => {
            const batchOperationType = batchOperationTypeStringToTypeMap.get(operation.type);
            const populatedTransaction = await operation.populateTransactionPromise;
            if (!batchOperationType) {
                throw new SFError_1.SFError({
                    type: "UNSUPPORTED_OPERATION",
                    message: "The operation at index " + index + " is unsupported.",
                });
            }
            /* istanbul ignore next */
            if (!populatedTransaction.to || !populatedTransaction.data) {
                throw new SFError_1.SFError({
                    type: "MISSING_TRANSACTION_PROPERTIES",
                    message: "The transaction is missing the to or data property.",
                });
            }
            const encoder = ethers_1.ethers.utils.defaultAbiCoder;
            // Handles Superfluid.callAgreement
            if (operation.type === "SUPERFLUID_CALL_AGREEMENT") {
                const functionArgs = this.getCallDataFunctionArgs(typechain_1.Superfluid__factory.abi, populatedTransaction.data);
                const data = encoder.encode(["bytes", "bytes"], [functionArgs["callData"], functionArgs["userData"]]);
                return {
                    operationType: batchOperationType,
                    target: functionArgs["agreementClass"],
                    data,
                };
            }
            // Handles Superfluid.callAppAction
            if (operation.type === "CALL_APP_ACTION") {
                const functionArgs = this.getCallDataFunctionArgs(typechain_1.Superfluid__factory.abi, populatedTransaction.data);
                return {
                    operationType: batchOperationType,
                    target: functionArgs["app"],
                    data: functionArgs["callData"],
                };
            }
            // Handles remaining ERC20/ERC777/SuperToken Operations
            return {
                operationType: batchOperationType,
                target: populatedTransaction.to,
                data: (0, utils_1.removeSigHashFromCallData)(populatedTransaction.data),
            };
        };
        /**
         * Executes a batch call given the operations on this class.
         * @param signer the signer of the transaction
         * @returns {Promise<ethers.ContractTransaction>} ContractTransaction object
         */
        this.exec = async (signer) => {
            if (this.getOperationStructArrayPromises.length === 0) {
                throw new SFError_1.SFError({
                    type: "BATCH_CALL_ERROR",
                    message: "There are no operations to execute in the batch.",
                });
            }
            const operationStructArray = await Promise.all(this.getOperationStructArrayPromises);
            return await this.host.contract
                .connect(signer)
                .batchCall(operationStructArray);
        };
        /* istanbul ignore next */
        // TODO: user signs the transaction they'd like to execute and gives
        // this data to the trusted forwarder to sign
        /**
         * Executes a forward batch call given the operations on this class.
         * @param signer the signer of the transaction
         * @returns {Promise<ethers.ContractTransaction>} ContractTransaction object
         */
        this.execForward = async (signer) => {
            if (this.getOperationStructArrayPromises.length === 0) {
                throw new SFError_1.SFError({
                    type: "BATCH_CALL_ERROR",
                    message: "There are no operations to execute in the batch.",
                });
            }
            const operationStructArray = await Promise.all(this.getOperationStructArrayPromises);
            return await this.host.contract
                .connect(signer)
                .forwardBatchCall(operationStructArray);
        };
        this.options = options;
        this.host = new Host_1.default(options.hostAddress);
    }
    /**
     * Gets an array of `OperationStruct` objects to be passed to batchCall.
     * @returns {Promise<OperationStruct>[]} array of operation struct promises
     */
    get getOperationStructArrayPromises() {
        return this.options.operations.map((x, i) => this.getOperationStruct(x, i));
    }
}
exports.default = BatchCall;
//# sourceMappingURL=BatchCall.js.map