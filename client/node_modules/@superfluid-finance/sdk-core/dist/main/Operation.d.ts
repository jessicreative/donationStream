import { TransactionRequest } from "@ethersproject/abstract-provider";
import { ethers } from "ethers";
export type BatchOperationType = "UNSUPPORTED" | "ERC20_APPROVE" | "ERC20_TRANSFER_FROM" | "ERC777_SEND" | "ERC20_INCREASE_ALLOWANCE" | "ERC20_DECREASE_ALLOWANCE" | "SUPERTOKEN_UPGRADE" | "SUPERTOKEN_DOWNGRADE" | "SUPERFLUID_CALL_AGREEMENT" | "CALL_APP_ACTION";
/**
 * Operation Helper Class
 * @description A helper class to create `Operation` objects which can be executed or batched.
 */
export default class Operation {
    readonly populateTransactionPromise: Promise<ethers.PopulatedTransaction>;
    readonly type: BatchOperationType;
    readonly forwarderPopulatedPromise?: Promise<ethers.PopulatedTransaction>;
    constructor(txn: Promise<ethers.PopulatedTransaction>, type: BatchOperationType, forwarderPopulatedPromise?: Promise<ethers.PopulatedTransaction>);
    /**
     * Executes the operation via the provided signer.
     * @description Populates all fields of the transaction, signs it and sends it to the network.
     * @param signer The signer of the transaction
     * @param gasLimitMultiplier A multiplier to provide gasLimit buffer on top of the estimated gas limit (1.2x is the default)
     * @returns {ethers.providers.TransactionResponse} A TransactionResponse object which can be awaited
     */
    exec: (signer: ethers.Signer, gasLimitMultiplier?: number) => Promise<ethers.providers.TransactionResponse>;
    /**
     * Get the populated transaction by awaiting `populateTransactionPromise`.
     * @description Note that we need to populate the txn with the signer.
     * NOTE: we use the forwarder populated promise if this exists
     * @returns {Promise<TransactionRequest>}
     */
    getPopulatedTransactionRequest: (signer: ethers.Signer, gasLimitMultiplier?: number) => Promise<TransactionRequest>;
    /**
     * Signs the populated transaction via the provided signer (what you intend on sending to the network).
     * @param signer The signer of the transaction
     * @returns {Promise<string>} Fully serialized, signed transaction
     */
    getSignedTransaction: (signer: ethers.Signer) => Promise<string>;
    /**
     * Gets the transaction hash of the transaction.
     * @description Calculates this by getting the keccak256 hash of the signedTxn.
     * @param signer The signer of the transaction
     * @returns {Promise<string>} The transaction hash of the transaction
     */
    getTransactionHash: (signer: ethers.Signer) => Promise<string>;
}
//# sourceMappingURL=Operation.d.ts.map