"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typechain_1 = require("@superfluid-finance/ethereum-contracts/build/typechain");
const ethers_1 = require("ethers");
class Governance {
    constructor(hostAddress, governanceAddress) {
        /**
         * Returns the 3Ps config for the specified token (or default) - the liquidation period and patrician period
         * @see https://docs.superfluid.finance/superfluid/sentinels/liquidations-and-toga
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @param token specified governance parameter token
         * @returns {Object} liquidationPeriod and patricianPeriod as strings
         */
        this.getPPPConfig = async ({ providerOrSigner, token = ethers_1.ethers.constants.AddressZero, }) => {
            const { liquidationPeriod, patricianPeriod } = await this.contract
                .connect(providerOrSigner)
                .getPPPConfig(this.hostAddress, token);
            return {
                liquidationPeriod: liquidationPeriod.toString(),
                patricianPeriod: patricianPeriod.toString(),
            };
        };
        /**
         * Returns the reward address for the specified token (or default)
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @param token specified governance parameter token
         * @returns {string} the reward address
         */
        this.getRewardAddress = async ({ providerOrSigner, token = ethers_1.ethers.constants.AddressZero, }) => {
            return await this.contract
                .connect(providerOrSigner)
                .getRewardAddress(this.hostAddress, token);
        };
        /**
         * Returns the minimum deposit for the specified token (or default)
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @param token specified governance parameter token
         * @returns {string} minimum deposit
         */
        this.getMinimumDeposit = async ({ providerOrSigner, token = ethers_1.ethers.constants.AddressZero, }) => {
            const superTokenMinimumDeposit = await this.contract
                .connect(providerOrSigner)
                .getSuperTokenMinimumDeposit(this.hostAddress, token);
            return superTokenMinimumDeposit.toString();
        };
        /**
         * Returns the relevant governance parameters
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @param token specified governance parameter token
         * @returns {Object} liquidationPeriod, patricianPeriod, rewardAddress and minimumDeposit
         */
        this.getGovernanceParameters = async ({ providerOrSigner, token = ethers_1.ethers.constants.AddressZero, }) => {
            const pppPromise = this.getPPPConfig({ providerOrSigner, token });
            const rewardPromise = this.getRewardAddress({
                providerOrSigner,
                token,
            });
            const minimumDepositPromise = this.getMinimumDeposit({
                providerOrSigner,
                token,
            });
            const data = await Promise.all([
                pppPromise,
                rewardPromise,
                minimumDepositPromise,
            ]);
            return {
                liquidationPeriod: data[0].liquidationPeriod,
                patricianPeriod: data[0].patricianPeriod,
                rewardAddress: data[1],
                minimumDeposit: data[2],
            };
        };
        this.contract = new ethers_1.ethers.Contract(governanceAddress, typechain_1.SuperfluidGovernanceII__factory.abi);
        this.hostAddress = hostAddress;
    }
}
exports.default = Governance;
//# sourceMappingURL=Governance.js.map